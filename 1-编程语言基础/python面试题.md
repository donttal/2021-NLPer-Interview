# Python 面试题
[toc]

## 垃圾回收机制

**引用计数为主，分代收集为辅。**在 python 中，如果一个对象的引用数为 0， python 虚拟机就会回收这个对象的内存。

- 导致引用计数 +1 的情况：

  > - 对象被创建： a = classname()
  > - 对象被引用： b = a
  > - 对象被作为参数，传入到一个函数中： func(a)
  > - 对象作为一个元素，存储在容器内： list_name = [a, a]

- 导致引用计数 -1 的情况：

  > - 对象的别名被显式销毁， 如： del a 
  > - 对象的别名被赋予新的对象，如：a = other_class()
  > - 一个对象离开它的作用域，如函数执行完毕时，func 函数中的局部变量
  > - 对象所在的容器被销毁，或从容器中删除对象

**循环引用导致内存泄漏**

```
c1=ClassA() # 内存 1 引用计数 +1 = 1
c2=ClassA() # 内存 2 引用计数 +1 = 1
c1.t=c2  #  内存 2 引用计数 +1 = 2
c2.t=c1  #  内存 1 引用计数 +1 = 2
del c1  # 内存 1 引用计数 -1 = 1
del c2  # 内存 2 引用计数 -1 = 1
```


## list和tuple有什么区别？

列表和元组之间的区别在于列表是可变的而元组不是。元组可以被散列，例如作为词典的关键。

## 为什么说python线程是伪线程？

但是在python中，**python虚拟机要求在主循环中同时只能有一个控制线程在运行，这也就意味着即使python解释器中可以运行多个线程，但是在任意时刻只有一个线程会被python解释器执行。**

而这正是由**GIL（全局解释器锁）**来控制的，它保证了同一时刻只能有一个线程运行，而在python多线程环境下，python虚拟机按照下面的 方式运行：

1. 设置GIL

2. 切换进一个线程取运行

3. 执行下面操作之一：

   > - 执行指定数量的字节码指令
   > - 线程主动让出控制权（time.sleep())

4. 把线程设置会睡眠状态（切换出线程）

5. 解锁GIL

6. 重复以上步骤

这也就是为什么说python的多线程适合于IO密集型，而不适合计算密集型任务。

### 什么是守护线程

守护线程可以视为其余非守护线程的保姆，只有所有非守护线程都退出了，守护线程才会终止。

threading模块支持守护线程，其工作方式是:守护线程一般是一个等待客户端请求服务的服务器。如果没有客户端请求,守护线程就是空闲的。